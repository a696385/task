{"ts":1361169210949,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\nmodule.exports = exports = {\n    Task: Task,\n    Deferred: Deferred,\n    Promise: Promise,\n    series: series\n};\n\nvar objectToArray = function(args, removeError){\n    removeError = removeError || false;\n    var result = [];\n    if (typeof args === 'object' && args instanceof Array)\n        result = args;\n    else if (typeof args === 'object')\n        for(var key in args)\n            result.push(args[key]);\n    else if (typeof args !== 'function')\n        result.push(args);\n    if (removeError)\n        result.splice(0,1);\n    return result;\n};\n\nvar nextTick = process.nextTick;\nfunction TaskAlreadyCompleted(){}\n\n/**\n * Create Deferred object\n * @return {Deferred}\n **/\n\nfunction Deferred(){\n    var self = this;        \n    self.onSuccess = [];\n    self.onError = [];\n    self.onFinally = [];    \n    self.comleted = false;\n    self.result = null;\n    self.error = null;  \n    self.thenDefs = [];    \n    \n    var doSuccess = function(args){\n        self.onSuccess.forEach(function(el){\n            nextTick(function(){\n                var result = null;\n                try{\n                    result = el.apply(self.bind,args);\n                }catch(e){\n                    self.comleted = false;\n                    self.reject(e);\n                    return;\n                }\n                if (typeof result === 'object' && result instanceof Deferred)\n                    result = result.promise;\n                if (typeof result === 'object' && result instanceof Promise)\n                    self.thenDefs.forEach(function(then){\n                        result.then(then.resolve, then.reject); \n                    });\n                else if (result != null)\n                    self.resolve(result);\n            });\n        });\n    };\n    \n    var doError = function(err){\n        self.onError.forEach(function(el){\n            nextTick(function(){\n                try{\n                    el.apply(self.bind,[err]);\n                }catch(e){ }\n            });\n        });\n    };\n    \n    var doDone = function(err, args){\n        var elargs = args || [];\n        if (err)\n            elargs.splice(0,0,err);\n        self.onFinally.forEach(function(el){\n            nextTick(function(){\n                try{\n                    el.apply(self.bind,elargs); \n                }catch(e){ }\n            });\n        });\n    };\n    \n    self.resolve = function(){\n        if (self.comleted) throw new TaskAlreadyCompleted();\n        var args = objectToArray(arguments);\n        self.comleted = true;\n        self.result = args;\n        if (self.result.length === 0)\n            self.result = null;\n        else if (self.result.length === 1)\n            self.result = self.result[0];   \n        doSuccess(args);        \n        doDone(null, args);\n    };\n    \n    self.reject = function(err){\n       if (self.comleted) throw new TaskAlreadyCompleted();\n       self.comleted = true;\n       self.error = err;\n       doError(err);\n       doDone(err);\n       self.thenDefs.forEach(function(el){\n          el.reject(err); \n       });\n    };    \n    \n    self.connectToDeferred = function(promise){\n        promise.success(self.resolve);\n        promise.error(self.reject);\n    };    \n    \n    self.promise = new Promise(self);\n}\n\n/**\n * Create Promise Object\n * @param def {Deferred}\n * @return {Promise}\n **/\nfunction Promise(def){\n    var self = this;\n    self.def = def;    \n    self.then = function(success, error, done){\n        self.done(done);\n        self.success(success);\n        self.error(error);    \n        return createThenDef();\n    };      \n    self.done = function(callback){\n        if (callback)\n            self.def.onFinally.push(callback);    \n        return createThenDef();\n    };\n    self.success = function(callback){\n        if (callback)\n            self.def.onSuccess.push(callback);    \n        return createThenDef();\n    };\n    self.error = function(callback){\n        if (callback)\n            self.def.onError.push(callback);    \n        return createThenDef();\n    };   \n    var createThenDef = function(){\n        var thenDef = new Deferred();\n        self.def.thenDefs.push(thenDef);\n        return thenDef.promise;        \n    };\n }\n \n \n /**Create Task object\n  * @param bind {Object} optional\n  * @param fn {Function} callFunction\n  * @return {Promise}\n  **/\n function Task(bind, fn){\n    var self = {};    \n    if (typeof bind === 'function' && !fn){\n        fn = bind;\n        bind = self;\n    }\n     if (!fn)\n        throw new SyntaxError();\n    self.bind = bind;\n    self.fn = fn;\n    self.def = new Deferred();\n    \n    if (fn.length === 0){\n        nextTick(function(){\n            var result = null;\n            try{\n                result = self.fn.apply(self.bind,[]);\n            }catch(e){\n                self.def.reject(e);\n                return;\n            }\n            if (typeof result === 'object' && result instanceof Deferred)\n                result = result.promise;\n            if (typeof result === 'object' && result instanceof Promise)\n                self.def.connectToDeferred(result);\n            else\n                self.def.resolve(result);                             \n        });    \n    } else {\n        var callback = function(err){        \n            if (err)\n                self.def.reject(err);        \n            else\n                self.def.resolve.apply(self.bind, objectToArray(arguments, true));\n        };\n        nextTick(function(){\n            try{\n                self.fn.apply(self.bind, [callback]);\n            }catch(e){\n                self.def.reject(e);\n                return;\n            }\n        });\n    }    \n    \n    return self.def.promise;\n }\n\n/**\n * For each array function in series\n * @param arr {Array}\n * @return {Promise}\n */\nfunction series(arr){\n    var def = new Deferred();\n    var keys = [];\n    for(var key in arr)\n        keys.push(key);\n    var index = 0;\n    var result = [];\n    var next = function(){\n        var key = keys[index],\n            el = arr[key];\n        var task = el;\n        if (typeof task === 'object' && result instanceof Deferred)\n            task = task.promise;\n        else if (!(typeof result === 'object' && result instanceof Promise))\n            task = Task(task);\n        task.then(function(){\n            var args = objectToArray(arguments);\n            if (args.length === 0)\n                args = null;\n            else if (args.length === 1)\n                args = args[0];\n            result[key] = args;\n\n            //To next tick\n            index++;\n            if (index >= keys.length){\n                def.resolve(result);\n                return;\n            } else nextTick(next);\n        },function(err){\n            def.reject(err);\n        });\n    };\n    if (keys.length > 0)\n        nextTick(next);\n    else\n        nextTick(function(){def.resolve(result)});\n    return def.promise;\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":6864}]],"length":6864}
{"contributors":[],"silentsave":false,"ts":1361169342861,"patch":[[{"diffs":[[0,": Task,\n"],[1,"    fTask: fTask,\n"],[0,"    Defe"]],"start1":38,"start2":38,"length1":16,"length2":34},{"diffs":[[0,"esult !="],[1,"="],[0," null)\n "]],"start1":1681,"start2":1681,"length1":16,"length2":17},{"diffs":[[0,".promise;\n}\n"],[1,"\n/**\n * Create paramtred Task\n * @param bind {Object} optional\n * @param fn {Function} callFunction\n * @return {Function}\n **/\nfunction fTask(bind, fn){\n    var self = {};    \n    if (typeof bind === 'function' && !fn){\n        fn = bind;\n        bind = self;\n    }\n     if (!fn)\n        throw new SyntaxError();\n    self.bind = bind;\n    self.fn = fn;\n    var result = function(){\n        \n    };\n    return result;\n}"]],"start1":6871,"start2":6871,"length1":12,"length2":430}]],"length":7301,"saved":false}
{"ts":1361169446244,"patch":[[{"diffs":[[0,"tion(){\n        "],[1,"var  args = objectToArray(arguments);\n        return Task(function(callback){\n            args.push(callback);\n           self.fn.apply(self.bind, args); \n        });"],[0,"\n    };\n    retu"]],"start1":7257,"start2":7257,"length1":32,"length2":198}]],"length":7467,"saved":false}
